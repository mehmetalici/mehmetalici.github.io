---
title: "How Writing Helps Me to Become Better at Work"
date: 2025-01-23
draft: true
description: ""
summary: "It is not AI Chatbots that speed things up: it is writing things down first."
slug: "advanced-customisation"
tags: ["advanced", "css", "docs"]
---
# How Writing Helps Me to Become Better at Work

Let's admit it: We always look for "Quick Start" section in every README. *Comprehensive* READMEs on the other hand? Well, no one reads those. 

Similarly for architectural documentations, our eyes search for graphic content (Ã¤hm diagrams). If they do good job in conveying the story, no need for wasting time on the bulky text surraounding it -right?

Talking about diagrams, they also look great on code comments. I can see you know what I mean: the ASCII art.

The thing is that our brains are evolved to save energy. A good software documenter should be aware of this fact. In another words, a good documentation should recognize its reader and its psychology well. 

We have been talking about what makes good documentation but this is not the point of this post. This post is also not about how to write documentation to help the readers at best. 

This post is actually about how good documentation enforces you to write good software. In another words, how good documentation -let it be READMEs, code comments or architectural diagrams- immensely helps, in fact, you as repository contributor and not the reader. 

A good question to ask now is, "Well, how can we define a good software?". Forget about tests, code coverage or adherence to best practices - well, we already know they are great. Here is a different take: A software is good when it is easy for a newcomer to understand it and contribute to it. 

Good software is written for the reader at the first place -for being understood by others. So, good software is *emphatethic* to its readers. 

That said, it is really hard to write *emphatetic* software. This is because when we develop software, we think for the problems and then implement our solution -it becomes challenging to consider the reader and keep the reader in the loop. It is exactly here where good documentation comes to rescue: When we write good documentation, we automatically strive to be objective. When we write, we take our time to justify our design decisions for our imaginary reader. 

Without documentation, on the other hand, our code is just a product of stream of thought. Code produced by stream of thought is a product of haste. However, code based on documentation is a product of reason.

Let's now think of some real-world examples:

We manage software projects with the so-called issues and they tell others how much progress we have been making. So, the initial benefit of writing issues is that it helps others. Although this is perfectly valid, here is another take on the topic: Writing issues is at least equally useful to the original author since it forces the author to break-down the work into manageable chunks. 

Writing good issues means justifying your work packages to your imaginary reader. It encourages you to provide rationales, assess time effort and draw boundaries of what the work package at hand is supposed to do - no more and no less. All those parts add together you to draft well thought-out work packages, which eventually helps immensely you to deliver the features on time. Writing good issue descriptions puts us to an objective 3rd-party state and understand the small problem better and eventually design a better thought-out solution. 

Let's go one step further in issues: The issue comments section, which is mainly empty if the repository is not a popular open source one. How does the idea of filling this section by our atomic milestones, infinitesimal findings or learnings as we work through the issue? 

Well, to me, it sounds great because it feels like keeping a diary -but in a professional setting. Just like personal diaries keep track of our daily events from the first-perspective, record problems we feel important and our coping strategies with them, keeping track of our work day in comments section should sound like a great idea. 

These comments help us to quantify our small achievements better, which is especially important not to easily 'get lost' on solution procedure. And you know what, after delivering the feature and closing the issue, you will have a track record of what-I-call issue evolution: Atomic problems, solution candidates and interesting findings. This comes with a beatiful side effect: A perfect documentation for your later self and others!

Before finishing, I would also like to touch shortly on nowadays' hype: AI chatbots. Well, I feel that they are, in fact, great tools particularly because they free my time to focus on high-level tasks by offloading my cognitive load for the low-level decisions. That said, I also read here and there that many actually suffer from AI chatbot usage for real-world tasks that it can no longer produce good code as the project's complexity grows. 

I find such claims hard to justify -especially without seeing the actual prompts. I feel this way because it is paramount to feed those chatbots good prompts, which we now call "prompt engineering". This is exactly to say that you need to convey them well what you want. So, the question becomes "how then provide good prompts?" Well, here is the takeaway: Good prompt engineering requires good writing! Good writing is also here a prerequisite to reap the full benefits of these chatbots.   

So, our thoughts are like a river: A continous stream of thought. They are transient, susceptible to distortions and without boundaries. On the other hand, writing is quite different: It requires more time, reasoning, objectivity and substantiation. Therefore, let's integrate writing more on our day-to-day development tasks, which will -believe me- lead to better software!   

